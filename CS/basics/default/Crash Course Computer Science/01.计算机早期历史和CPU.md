# 1. Early Computing`计算机早期历史`

1. 思考
    1. 人类对于数据的计算和存储的要求催生了计算机器和计算机
2. 内容
    1. 早期计算设备
        1. 算盘
        2. 星盘
        3. 计算尺
        4. 其他：计算日出、潮汐、天梯、计时等。。。
    2. computer 的含义
        1. 直到1800年代：负责计算的人(职业)
        2. 之后：负责计算的机器(工具)
    3. 计算机发展及应用`参见引用 1`
        1. 步进计算机
        2. 计算表格-射程表
        3. 差分机
        4. 分析机`通用计算机`
            1. Ada Lovelace 假想程序
        5. 打孔卡片制表机-人口普查`机械计数，电动结构连接`
            1. 制表机器公司-IBM
3. 引用
    1. [现代计算机出现前的各种“早期计算器”](https://zhuanlan.zhihu.com/p/149319970)

# 2. Electronic Computing`电子计算机`

1. 内容

    1. (机械)继电器 `用于控制电路，无法快速切换状态(开关)`

       ```text
        1940年代一个好的继电器可以切换50次/秒  
        机械磨损，不可靠  
        “bug”的来源
       ```

        1. 使用场景代表
            1. 哈佛 Mark I : 最大的机电计算机之一`用于“曼哈顿计划”`

    2. 真空管/电子管/胆管

        1. 二极管：单向导电
        2. 三极管：二极管 + 放大电流`每秒上千次`
        3. 使用场景代表
            1. 巨人1号：第一台大规模使用电子管的(电子)计算机.第一个可编程的计算机?
            2. ENIAC：电子数值积分计算机.第一个真正的通用,可编程的电子计算机  
               每秒5000次十位数加减法

    3. 晶体管

        1. 使用场景代表
            1. IBM 608(1957年)：第一个完全使用晶体管的商业计算机  
               每秒4500次加法或80次乘除法

    4. 其他

        1. 硅谷
        2. Intel

2. 引用

    1. [蠢蠢欲动的机电计算时代](https://zhuanlan.zhihu.com/p/134302240)
    2. [到底什么是电子管（真空管）？](https://zhuanlan.zhihu.com/p/595416475)

# 3. Boolean Logic & Logic Gates`布尔逻辑 和 逻辑门`

1. 思考

    1. 在某种意义上，科学是人们对现实生活的总结和分析.人们在掌握某些自然原理后,使用已存在的事物 组合/生产/制作 出了新的事物.

    2. 人工造物大部分是出于某种目的而制造出来的.学习这些东西时可以从目的出发,然后再去学习实现目的的原理.

    3. 科技树和进化树一样,经过漫长的分化/尝试.很多分支胜出可能是因为某些因素的巧合,而不是因为某些分支本身就更优秀.

    4. 抽象是对系统和功能的简要描述和规范说明,封装是对象对其内部数据和操作的隐藏

       ```text
       封装填补了抽象留下的空白.通过封装实现抽象
       ```

2. 内容

    1. 前情回顾

        1. 计算机最早是机电设备,一般用齿轮数十进制
        2. 晶体管可以用开关表示二进制，还可以让不同大小的电流经过
            1. 早期电子计算机是三进制
            2. 状态越多，越难区分信号.电磁干扰和损耗.只用"开/关"两种状态可以避免这类问题

    2. 布尔代数`数学分支`: 专门处理"真(True)/假(False)"

       ```text
       乔治·布尔(1815-1864)用数学式子扩展亚里士多德基于哲学的逻辑方法. 
       用 逻辑方程 证明 真理(truth) 在 常规代数里 是数字,可以进行加法或者乘法运算.
       布尔代数的值：True/False
       基本操作: AND, OR, NOT
       ```

    3. 用晶体管实现布尔代数(和数据：真和假)

        1. 单个晶体管-真值: (一个输入)1个控制,1个输出

           | 输入 | 输出 |
           |----|----|
           | 1  | 1  |
           | 0  | 0  |

        2. NOT门(1个晶体管): 1个控制(输入),1个输出

           | 输入 | 输出 |
           |----|----|
           | 1  | 0  |
           | 0  | 1  |

        3. AND门(2个晶体管 串联): 2个控制(输入),1个输出

           | 输入A | 输入B | 输出 |
           |-----|-----|----|
           | 0   | 0   | 0  |
           | 0   | 1   | 0  |
           | 1   | 0   | 0  |
           | 1   | 1   | 1  |

        4. OR门(2个晶体管 并联): 2个控制(输入),1个输出

           | 输入A | 输入B | 输出 |
           |-----|-----|----|
           | 0   | 0   | 0  |
           | 0   | 1   | 1  |
           | 1   | 0   | 1  |
           | 1   | 1   | 1  |

        5. XOR门(1×OR,2×AND,1×NOT): 2个控制(输入),1个输出

           ```text
           1. 使用 OR 排除 2个False
           2. 使用 AND + NOT 筛选出两个True(结果为False)
           3. 使用 AND 合并 1和2,筛选出符合XOR的结果
           ```

           | 输入A | 输入B | 输出 |
           |-----|-----|----|
           | 0   | 0   | 0  |
           | 0   | 1   | 1  |
           | 1   | 0   | 1  |
           | 1   | 1   | 0  |

# 4. Representing Numbers and Letters with Binary`用二进制表示数字和字母`

1. 思考(**用词及其不准确的个人见解,仅用来帮助熟悉信息,二进制等**)

    1. 用信息/数据 来表示 环境/物质世界/宇宙

       ```text
       如果我们尝试用数据来描述、记录生活(世界/宇宙),我们应该关注什么? 区别 different.
       没有计算机之前,我们我们通过文字、图像、声音等来描述和记录世界.这些方法其实都是用来传递信息.
       信息是什么?信息是区别的记录和描述.
         
       描述区别最少只需要两个 标志/元素:我和你,无和有(1 and 0),这个和那个(This and that). True and False.
       对于'我'来讲,'你'和'他'都是'别人'.对于'0'来讲,任何正整数都是'正数',是有值的.
       用声音来传递信息可能是最古老的方式,发声和不发声,发声时间的长短,发声的频率,发声的音调,都有区别.
         
       是否可以认为 两个标志/元素的区别是 最小 的区别单位?
       十进制用10个数字表示区别,时间用24和60个数字表示区别.日期用12和31个数字表示区别.
       但是他们都可以被转化为二进制,用2个数字表示区别.
       如果只用一个数字,我们如何表示区别呢?这个原子和那个原子?这个生物和那个?这个星球和那个星球?
       
       数学和语言是人类对现实世界的描述和记录,并不是说有了数学才有了现实世界.
       一棵树上有10个苹果,另一棵树上有20个苹果,即使是在地球上出现人类以前,它们没有区别吗?太阳系的行星在人类出现前没有区别吗?
       这些客观存在的事物和变化,难道是人类出现的一瞬间才产生的吗?
       不要玩文字游戏.我们说两个苹果的不同,一定是因为有某个坐标系或者说某个标准(参考系?),才能说两个苹果不同.
       如第一个苹果在桌子左上角,第二个苹果在桌子右下角,这两个苹果的不同就是他们的坐标不同.
       第一个苹果比较大,第二个苹果比较小,这两个苹果的不同就是他们的大小不同.
       当然,使用不同的坐标系/参考系,可能会对同样的事物有不同的描述.如虽然两个苹果的坐标不同,但是他们的大小相同.
       重复一边,不要玩文字游戏,比如白马非马,或者'在我没有观测的时候,这两个苹果一定存在吗?'.
       ```

    2. 信息论

2. 内容

    1. 位`bit`: 二进制的最小单位`8位可以表示256种不同的状态`

    2. 字节`byte`: 8位

        1. 千字节kb(thousand bytes)
        2. 兆字节mb Mega(million bytes)
        3. 千兆字节gb Giga(billion bytes)
        4. 太字节tb Tera(trillion bytes).
        5. 以上单位的换算:1000和1024都可以.

    3. 计算机中的8位,32位,64位指的是电脑最小处理数据的单位.`8位机,8位图像,8位音乐`

    4. 用二进制表示负数.现有的大部分计算机把处理的二进制数字最高位作为符号位,0表示正数,1表示负数.用剩下的位表示数字的大小.

    5. 用二进制表示非整数:浮点数 floating-point number`小数点可以在数字间浮动`

       ```text
       32位浮点数: 1位符号位,8位指数位,23位尾数位(有效位数)
       ```

    6. 用二进制表示文字,符号,大小写,数字

        1. ASCII码: 7位二进制数,共128个字符`换行和回车`
        2. Unicode: 16位二进制数,统一编码方案.

3. 引用

    1. [IEEE 754](https://zh.wikipedia.org/zh-cn/IEEE_754)
    2. [浮点数](https://zh.wikipedia.org/zh-cn/%E6%B5%AE%E7%82%B9%E6%95%B0)

# 5. How Computers Calculate-the ALU`算术逻辑单元`

1. 思考

    1. 前文:表示和存储数字是计算机的重要功能.但真正的目标是计算,有意义的处理数字.这些操作由ALU处理.

2. 内容

    1. ALU: 计算机里负责数学运算的部件  
       ALU有2个单元,一个用来计算(算术单元),一个用来控制计算(逻辑单元).

        1. 算术单元`负责操作系统内的数字操作`
        2. 逻辑单元`负责操作系统内的逻辑操作`

    2. 历史上的ALU/ALU发展史

        1. Intel 74181: 第一个封装在单个芯片内的完整ALU

    3. 用布尔逻辑门实现算术单元

        1. 加法

            1. 半加器(只处理一位,并且没有进位): 两个输入,一个输出.输入和输出都是单个bit(1或者0)

               ```text
               使用XOR表示输出,使用AND表示进位
               ```

               | 输入A | 输入B | 进位 | 输出 |
               |-----|-----|----|----|
               | 0   | 0   | 0  | 0  |
               | 0   | 1   | 0  | 1  |
               | 1   | 0   | 0  | 1  |
               | 1   | 1   | 1  | 0  |

            2. 全加器(只处理1位,但是有进位): 三个输入,两个输出.输入和输出都是单个bit(1或者0)

               ```text
               使用两个半加器和一个OR门.
               第一个半加器处理前两个bit相加,第二个半加器把第一个半加器的输出和第三个bit相加.
               用OR门连接两个半加器的进位:三个bit相加,最大情况会进1位,要么前两个bit相加进位,要么相加结果和第三个bit相加进位.
               ```

               | 输入A | 输入B | 输入C | 进位 | 输出 |
               |-----|-----|-----|----|----|
               | 0   | 0   | 0   | 0  | 0  |
               | 1   | 0   | 0   | 0  | 1  |
               | 0   | 1   | 0   | 0  | 1  |
               | 0   | 0   | 1   | 0  | 1  |
               | 1   | 1   | 0   | 1  | 0  |
               | 1   | 0   | 1   | 1  | 0  |
               | 0   | 1   | 1   | 1  | 0  |
               | 1   | 1   | 1   | 1  | 1  |

            3. 8位行波进位加法器:1个半加器和7个全加器.两个8bit输入,一个8bit输出和一个进位.

            4. 现代计算机使用的ALU: 超前进位加法器.

        2. 乘法

            1. 简单处理器: 使用加法实现
            2. 手机电脑等: 专门做乘法的算术单元

    4. 用布尔逻辑门实现逻辑单元

    5. 加法ALU的操作

        1. 输入: 两个操作数 input, 一个操作符 operation code
        2. 输出: 1个输出 output, 一些标志 flag bit(overflow, zero, negative)

# 6. Registers and RAM`寄存器 & 内存`

1. 思考

    1. 位宽是指数据通道中一个时钟周期能发送/接受的数据位数（二进制的）.

2. 内容

    1. 单向电路和回向电路

        1. 记录'1': 将OR门的输出连接到一个输入
        2. 记录'0': 将AND门的输出连接到一个输入

    2. AND-OR锁存器 latch: 1个复位输入(set 0), 1个设置输入(set 1), 1个输出

       ```text
       '锁定'了一个值,直到复位或者设置.
       放入数据的动作叫做'写入' writing,取出数据的动作叫做'读取' reading.
       ```

    3. 门锁 Gated Latch: 1个输入, 1个控制(允许写入), 1个输出

    4. 寄存器: 一组锁存器. 锁存器的个数决定了寄存器的'位宽'.

       ```text
       早期电脑用8位寄存器, 然后是16位, 32位, 64位.
       参考引用2和3.
       如果要处理单个64位寄存器, 需要64个输入,64个输出,1个控制信号(允许写入).
       同理,存储256位寄存器需要 256+256+1=513条线.
       ```

    5. 门锁矩阵

       ```text
       使用16×16网格的锁存器.可以存储256 个 bit 的数据.
       需要16条行线和16条列线, 1条 数据线(连接所有的锁存器),1条 允许读取线(同上),1条 允许写入线(同上).
       要写入/读取某个锁存器,就打开相应的行线和列线,和相应的控制线即可.
       ```

    6. 多路复用器

       ```text
       用来指定门锁矩阵的行线和列线.
       16×16的门锁矩阵,需要2个(1-16)多路复用器,一个用来选择行线,一个用来选择列线.
       分别接受两个4位二进制数(4个bit,16个数字,16个'区别'),用来选择行线和列线.
       
       基于此,我们可以把256位内存看做一个整体.
       输入一个8位地址(4位代表行,4位代表列),一根数据线,一根允许读取线,一根允许写入线.
       ```

    7. (基于多路复用门锁矩阵的)SRAM 静态随机存取存储器

       ```text
       把8个16×16的门锁矩阵连接起来,公用一个8位(二进制)地址,数据线(8位的二进制数据),允许读取线,允许写入线.    
       用每个门锁矩阵的 相同地址 依次 存放8bit数据的其中一个bit,也就是一个字节 Byte.
       因此共可存储256个(16×16)字节Byte,也就是256个8bit(8个门锁矩阵)的数据.
       ```

       模拟(8位)可寻址内存的存放情况

       | 存放的数据    | (内存的)地址 | (内存的)地址二进制 | 矩阵1 | 矩阵2 | 矩阵3 | 矩阵4 | 矩阵5 | 矩阵6 | 矩阵7 | 矩阵8 |
       |----------|---------|------------|-----|-----|-----|-----|-----|-----|-----|-----|
       | 00000000 | 0       | 00000000   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
       | 00001111 | 1       | 00000001   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   |
       | 11110000 | 2       | 00000010   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 0   |
       | 11000011 | 3       | 00000011   | 1   | 1   | 0   | 0   | 0   | 0   | 1   | 1   |
       | 00111100 | 4       | 00000100   | 0   | 0   | 1   | 1   | 1   | 1   | 0   | 0   |

    8. RAM 随机读取存储器

3. 引用

    1. [36 计算机科学速成课 06：计算机内存、锁存器、门锁矩阵、寻址地址、随机存储器(KK)](https://zhuanlan.zhihu.com/p/103963489)
    2. [Windows上的64位和32位的区别是什么？超详细科普！！](https://zhuanlan.zhihu.com/p/156047744)
    3. [内存的位宽必须和cpu的数据总线的位宽一致吗？ - 木头龙的回答 - 知乎](https://www.zhihu.com/question/57414970/answer/153359328)

# 7. The Central Processing Unit(CPU)`中央处理器`

1. 思考
2. 内容
    1. 前情提要
        1. ALU
        2. 寄存器
        3. RAM
    2. CPU 中央处理器`负责执行程序`
        1. 组成
            1. 一些寄存器
            2. 指令寄存器
            3. 指令地址寄存器
        2. (执行程序的)运行流程`把控制单元抽象为一个整体`
            1. 取指令
                1. 指令地址寄存器地址为0000 0000
                2. 取RMA中address 0000 0000处的数据,复制到指令寄存器中
            2. 执行指令
                1. 把指令寄存器中的指令分为操作码和地址
                2. (略过check操作)根据地址取RAM中的值, 并写入寄存器
            3. 指令地址寄存器+1
        3. 时钟以精确的间隔触发电信号, 控制单元用信号推动CPU内部操作
            1. CPU取指令->解码->执行 的速度叫时钟速度, 单位赫兹 Hertz. 1Hz代表1秒一个周期.
            2. 第一个单芯片CPU是 Intel 4004, 740k Hz
            3. 超频 over clocking`加快CPU时钟频率, 耗电`
            4. 降频 under clocking `降低频率, 省电`

# 8. Instructions & Programs`指令和程序`

1. 思考
2. 内容
    1. CPU 常用指令
        1. load
        2. store
        3. add
        4. sub
        5. jump`用指令后四位代表的内存地址值覆盖'指令地址寄存器'里的值`
        6. jump_neg`只在ALU 负数标志 为真时 JUMP`
        7. halt

    2. 用软件实现余数和除法`软件可以实现硬件不能实现的效果和操作`
    3. 解决指令长度问题
        1. 增加指令长度`用更多位来存储/代表指令`
        2. 可变指令长度
            1. 不需要参数的指令
            2. 需要参数的指令: 参数存放在 JUMP指令后面`立即值 immediate value`

# 9. Advanced CPU Designs`高级CPU设计`

1. 思考

2. 内容

    1. 计算机提速(处理速度)方式

        1. 早期: 减少晶体管切换时间

        2. 其他(晶体管切换速度提升不大时)

            1. 提供相对应的硬件支持, 同时让ALU更大, 更复杂.

               ```text
               用硬件提供除法指令 替代 减法(软件层面)实现除法.
               现代处理器用专门电路(指令集?)处理图形操作,解码,压缩,加密...
               为了兼容旧指令集,指令数量越来越多.
               ```

    2. 解决延迟: 如何快速传递数据给CPU

       ```text
       RAM和CPU之间通过总线`bus`传递数据.
       RAM还需要取数据,配置,输出数据. 一条`从内存读数据`的指令可能需要多个时钟周期.在这期间,CPU空等数据(如果不加以优化).
       ```

        1. 在CPU内部增加缓存`cache`.一般KB或者MB大小`RAM GB起步`.

            1. 批量取数据
               ```text
               CPU从RAM取数据时,一次取一批数据(之前是一个). 因为数据常常按顺序依次处理.可以在一个时钟周期内完成操作.
               缓存命中 cache hit: 想获取的数据已经在缓存中
               缓存未命中 cache miss: ...不在缓存中.
               ```

            2. 缓存充当临时空间,存储中间值.

                1. 缓存和内存不一致(数据没有及时更新到内存).

                   ```text
                   (每块?)缓存设置 '脏位' dirty bit.
                   缓存满了并且CPU需要使用新的缓存时,检查'脏位',如果 dirty,先把数据回写到RAM.
                   ```

    3. 提升性能: 指令流水线`instruction pipelining`

       ```text
       原有方式:读取A解码A执行A,读取B解码B执行B,读取C解码C执行C
       流水线: '执行'一个指令时, '解码'下一个指令, '读取'下下个指令.不同任务重叠执行,提升吞吐量.
           读取A,读取B解码A,读取C解码B执行C...
       ```

       	1. 指令可能依赖数据: 乱序执行, 动态排序(指令)
       	1. 条件跳转: 分支预测(推测执行?)

    4. (单个指令流)一个时钟周期执行多条指令: 超标量处理器

    5. 同时运行多个指令流: 多核处理器

    6. 多个CPU

        1. 服务器多个CPU

        2. 超级计算机

           ```text
           每秒浮点运算次数 FLOPS
           ```

# 10. Early Programming`早期的编程方式`

1. 思考

2. 内容

    1. 穿孔纸卡

        1. 纺织业-图案和花色需要调整

           ```text
           可编程纺织机: 穿孔纸卡 连成长条,形成连续指令.(便宜 可靠 易懂)
           ```

        2. 美国人口普查1890`早期汇总机不属于计算机,仅用于汇总数据.操作是固定的, 不能编程`

    2. 控制面板/插线板(用连接线控制程序)

    3. 存储程序计算机

       ```text
       冯诺依曼结构: 程序和数据存储在一个地方(内存)
       用一叠卡片/卡纸记录程序和数据,程序和数据写入完成后,开始执行
       ```

    4. 开关,按钮,指示灯 代替插线板

       ```text
       避免穿孔纸卡读取器等外围设备费用
       ```